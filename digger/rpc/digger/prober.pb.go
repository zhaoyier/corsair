// Code generated by protoc-gen-go. DO NOT EDIT.
// source: digger/prober.proto

package digger

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = strings.TrimPrefix

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type _EastMoneyTypeEnum struct {
	Unknown    EastMoneyType
	Holder     EastMoneyType
	News       EastMoneyType
	Operations EastMoneyType
	GPList     EastMoneyType
	TotalSize  int
	List       []EastMoneyType
	ZeroList   []EastMoneyType
}

var EastMoneyTypeEnum = _EastMoneyTypeEnum{
	0,
	1,
	2,
	3,
	4,
	5,
	[]EastMoneyType{
		EastMoneyType_EastMoneyTypeHolder,
		EastMoneyType_EastMoneyTypeNews,
		EastMoneyType_EastMoneyTypeOperations,
		EastMoneyType_EastMoneyTypeGPList,
	},
	[]EastMoneyType{
		EastMoneyType_EastMoneyTypeUnknown,
		EastMoneyType_EastMoneyTypeHolder,
		EastMoneyType_EastMoneyTypeNews,
		EastMoneyType_EastMoneyTypeOperations,
		EastMoneyType_EastMoneyTypeGPList,
	},
}

func (x *_EastMoneyTypeEnum) Parse(short string) EastMoneyType {
	return EastMoneyType(EastMoneyType_value["EastMoneyType"+strings.TrimPrefix(short, "EastMoneyType")])
}

func (x EastMoneyType) IsUnknown() bool {
	return x == EastMoneyTypeEnum.Unknown
}

func (x EastMoneyType) GetUnknown() EastMoneyType {
	return EastMoneyTypeEnum.Unknown
}

func (x EastMoneyType) IsHolder() bool {
	return x == EastMoneyTypeEnum.Holder
}

func (x EastMoneyType) GetHolder() EastMoneyType {
	return EastMoneyTypeEnum.Holder
}

func (x EastMoneyType) IsNews() bool {
	return x == EastMoneyTypeEnum.News
}

func (x EastMoneyType) GetNews() EastMoneyType {
	return EastMoneyTypeEnum.News
}

func (x EastMoneyType) IsOperations() bool {
	return x == EastMoneyTypeEnum.Operations
}

func (x EastMoneyType) GetOperations() EastMoneyType {
	return EastMoneyTypeEnum.Operations
}

func (x EastMoneyType) IsGPList() bool {
	return x == EastMoneyTypeEnum.GPList
}

func (x EastMoneyType) GetGPList() EastMoneyType {
	return EastMoneyTypeEnum.GPList
}

func (x EastMoneyType) Valid() bool {
	if x == EastMoneyType_EastMoneyTypeUnknown {
		return false
	}
	return x.ZeroValid()
}

func (x EastMoneyType) ZeroValid() bool {
	_, ok := EastMoneyType_name[int32(x)]
	return ok
}
func (x EastMoneyType) Short() string {
	n := x.String()
	typ := "EastMoneyType"
	if len(n) > len(typ) {
		if n[:len(typ)] == typ {
			return n[len(typ):]
		}
	}
	return n

}
func (x *EastMoneyType) SetValue(v int32) {
	*x = EastMoneyType(v)
}

func (x EastMoneyType) GetValue() int32 {
	return int32(x)
}

func (x *EastMoneyType) Type() string {
	return "EastMoneyType"
}

type EastMoneyType int32

const (
	EastMoneyType_EastMoneyTypeUnknown    EastMoneyType = 0
	EastMoneyType_EastMoneyTypeHolder     EastMoneyType = 1
	EastMoneyType_EastMoneyTypeNews       EastMoneyType = 2
	EastMoneyType_EastMoneyTypeOperations EastMoneyType = 3
	EastMoneyType_EastMoneyTypeGPList     EastMoneyType = 4
)

var EastMoneyType_name = map[int32]string{
	0: "EastMoneyTypeUnknown",
	1: "EastMoneyTypeHolder",
	2: "EastMoneyTypeNews",
	3: "EastMoneyTypeOperations",
	4: "EastMoneyTypeGPList",
}

var EastMoneyType_value = map[string]int32{
	"EastMoneyTypeUnknown":    0,
	"EastMoneyTypeHolder":     1,
	"EastMoneyTypeNews":       2,
	"EastMoneyTypeOperations": 3,
	"EastMoneyTypeGPList":     4,
}

func (x EastMoneyType) String() string {
	return proto.EnumName(EastMoneyType_name, int32(x))
}

func (EastMoneyType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f34ec7a831e4a2b5, []int{0}
}

type _RMTypeEnum struct {
	RmTypeUnknown RMType
	RmTypeShort   RMType
	RmTypeLong    RMType
	TotalSize     int
	List          []RMType
	ZeroList      []RMType
}

var RMTypeEnum = _RMTypeEnum{
	0,
	1,
	2,
	3,
	[]RMType{
		RMType_RmTypeShort,
		RMType_RmTypeLong,
	},
	[]RMType{
		RMType_RmTypeUnknown,
		RMType_RmTypeShort,
		RMType_RmTypeLong,
	},
}

func (x *_RMTypeEnum) Parse(short string) RMType {
	return RMType(RMType_value["RMType"+strings.TrimPrefix(short, "RMType")])
}

func (x RMType) IsRmTypeUnknown() bool {
	return x == RMTypeEnum.RmTypeUnknown
}

func (x RMType) BitHasRmTypeUnknown() bool {
	return x.BitHas(RMTypeEnum.RmTypeUnknown)
}

func (x RMType) BitOrRmTypeUnknown() RMType {
	x.BitOr(RMTypeEnum.RmTypeUnknown)
	return x
}

func (x RMType) GetRmTypeUnknown() RMType {
	return RMTypeEnum.RmTypeUnknown
}

func (x RMType) IsRmTypeShort() bool {
	return x == RMTypeEnum.RmTypeShort
}

func (x RMType) BitHasRmTypeShort() bool {
	return x.BitHas(RMTypeEnum.RmTypeShort)
}

func (x RMType) BitOrRmTypeShort() RMType {
	x.BitOr(RMTypeEnum.RmTypeShort)
	return x
}

func (x RMType) GetRmTypeShort() RMType {
	return RMTypeEnum.RmTypeShort
}

func (x RMType) IsRmTypeLong() bool {
	return x == RMTypeEnum.RmTypeLong
}

func (x RMType) BitHasRmTypeLong() bool {
	return x.BitHas(RMTypeEnum.RmTypeLong)
}

func (x RMType) BitOrRmTypeLong() RMType {
	x.BitOr(RMTypeEnum.RmTypeLong)
	return x
}

func (x RMType) GetRmTypeLong() RMType {
	return RMTypeEnum.RmTypeLong
}

func (x RMType) Valid() bool {
	if x == RMType_RmTypeUnknown {
		return false
	}
	return x.ZeroValid()
}

func (x RMType) ZeroValid() bool {
	_, ok := RMType_name[int32(x)]
	return ok
}
func (x RMType) Short() string {
	n := x.String()
	typ := "RMType"
	if len(n) > len(typ) {
		if n[:len(typ)] == typ {
			return n[len(typ):]
		}
	}
	return n

}
func (x RMType) BitString() []string {
	name := make([]string, 0, len(RMTypeEnum.List))
	for _, item := range RMTypeEnum.List {
		if x.BitHas(item) {
			name = append(name, item.Short())
		}
	}
	return name

}

func (x RMType) BitValid() bool {
	return x.BitHas(RMTypeEnum.List...)
}
func (x *RMType) BitOr(item RMType) {
	*x |= item
}
func (x RMType) BitHas(xs ...RMType) bool {
	for _, item := range xs {
		if x&item > 0 {
			return true
		}
	}
	return false
}

func (x *RMType) SetValue(v int32) {
	*x = RMType(v)
}

func (x RMType) GetValue() int32 {
	return int32(x)
}

func (x *RMType) Type() string {
	return "RMType"
}

type RMType int32

const (
	RMType_RmTypeUnknown RMType = 0
	RMType_RmTypeShort   RMType = 1
	RMType_RmTypeLong    RMType = 2
)

var RMType_name = map[int32]string{
	0: "RmTypeUnknown",
	1: "RmTypeShort",
	2: "RmTypeLong",
}

var RMType_value = map[string]int32{
	"RmTypeUnknown": 0,
	"RmTypeShort":   1,
	"RmTypeLong":    2,
}

func (x RMType) String() string {
	return proto.EnumName(RMType_name, int32(x))
}

func (RMType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f34ec7a831e4a2b5, []int{1}
}

//1准备,2开始, 3进行中,4结束,5放弃
type _RMStateEnum struct {
	Unknown    RMState
	Prepared   RMState
	Started    RMState
	InProgress RMState
	Over       RMState
	Abandoned  RMState
	TotalSize  int
	List       []RMState
	ZeroList   []RMState
}

var RMStateEnum = _RMStateEnum{
	0,
	1,
	2,
	3,
	4,
	5,
	6,
	[]RMState{
		RMState_RMStatePrepared,
		RMState_RMStateStarted,
		RMState_RMStateInProgress,
		RMState_RMStateOver,
		RMState_RMStateAbandoned,
	},
	[]RMState{
		RMState_RMStateUnknown,
		RMState_RMStatePrepared,
		RMState_RMStateStarted,
		RMState_RMStateInProgress,
		RMState_RMStateOver,
		RMState_RMStateAbandoned,
	},
}

func (x *_RMStateEnum) Parse(short string) RMState {
	return RMState(RMState_value["RMState"+strings.TrimPrefix(short, "RMState")])
}

func (x RMState) IsUnknown() bool {
	return x == RMStateEnum.Unknown
}

func (x RMState) GetUnknown() RMState {
	return RMStateEnum.Unknown
}

func (x RMState) IsPrepared() bool {
	return x == RMStateEnum.Prepared
}

func (x RMState) GetPrepared() RMState {
	return RMStateEnum.Prepared
}

func (x RMState) IsStarted() bool {
	return x == RMStateEnum.Started
}

func (x RMState) GetStarted() RMState {
	return RMStateEnum.Started
}

func (x RMState) IsInProgress() bool {
	return x == RMStateEnum.InProgress
}

func (x RMState) GetInProgress() RMState {
	return RMStateEnum.InProgress
}

func (x RMState) IsOver() bool {
	return x == RMStateEnum.Over
}

func (x RMState) GetOver() RMState {
	return RMStateEnum.Over
}

func (x RMState) IsAbandoned() bool {
	return x == RMStateEnum.Abandoned
}

func (x RMState) GetAbandoned() RMState {
	return RMStateEnum.Abandoned
}

func (x RMState) Valid() bool {
	if x == RMState_RMStateUnknown {
		return false
	}
	return x.ZeroValid()
}

func (x RMState) ZeroValid() bool {
	_, ok := RMState_name[int32(x)]
	return ok
}
func (x RMState) Short() string {
	n := x.String()
	typ := "RMState"
	if len(n) > len(typ) {
		if n[:len(typ)] == typ {
			return n[len(typ):]
		}
	}
	return n

}
func (x *RMState) SetValue(v int32) {
	*x = RMState(v)
}

func (x RMState) GetValue() int32 {
	return int32(x)
}

func (x *RMState) Type() string {
	return "RMState"
}

type RMState int32

const (
	RMState_RMStateUnknown    RMState = 0
	RMState_RMStatePrepared   RMState = 1
	RMState_RMStateStarted    RMState = 2
	RMState_RMStateInProgress RMState = 3
	RMState_RMStateOver       RMState = 4
	RMState_RMStateAbandoned  RMState = 5
)

var RMState_name = map[int32]string{
	0: "RMStateUnknown",
	1: "RMStatePrepared",
	2: "RMStateStarted",
	3: "RMStateInProgress",
	4: "RMStateOver",
	5: "RMStateAbandoned",
}

var RMState_value = map[string]int32{
	"RMStateUnknown":    0,
	"RMStatePrepared":   1,
	"RMStateStarted":    2,
	"RMStateInProgress": 3,
	"RMStateOver":       4,
	"RMStateAbandoned":  5,
}

func (x RMState) String() string {
	return proto.EnumName(RMState_name, int32(x))
}

func (RMState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f34ec7a831e4a2b5, []int{2}
}

//权重单元
type WeightUnit struct {
	//
	Value float64 `protobuf:"fixed64,1,opt,name=value,proto3" json:"value"`
	//
	Accum float64 `protobuf:"fixed64,2,opt,name=accum,proto3" json:"accum"`
	//
	Consecutive int32 `protobuf:"varint,3,opt,name=consecutive,proto3" json:"consecutive"`
	//
	Counter int32 `protobuf:"varint,4,opt,name=counter,proto3" json:"counter"`
	//
	Present float64 `protobuf:"fixed64,5,opt,name=present,proto3" json:"present"`
	//
	SubNew bool `protobuf:"varint,6,opt,name=subNew,proto3" json:"subNew"`
}

func (m *WeightUnit) Validate() error {
	return nil
}

func (m *WeightUnit) Reset()         { *m = WeightUnit{} }
func (m *WeightUnit) String() string { return proto.CompactTextString(m) }
func (*WeightUnit) ProtoMessage()    {}
func (*WeightUnit) Descriptor() ([]byte, []int) {
	return fileDescriptor_f34ec7a831e4a2b5, []int{0}
}

func (m *WeightUnit) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_WeightUnit.Unmarshal(m, b)
}
func (m *WeightUnit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_WeightUnit.Marshal(b, m, deterministic)
}
func (m *WeightUnit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WeightUnit.Merge(m, src)
}
func (m *WeightUnit) XXX_Size() int {
	return xxx_messageInfo_WeightUnit.Size(m)
}
func (m *WeightUnit) XXX_DiscardUnknown() {
	xxx_messageInfo_WeightUnit.DiscardUnknown(m)
}

var xxx_messageInfo_WeightUnit proto.InternalMessageInfo

func (m *WeightUnit) GetValue() float64 {
	if m != nil {
		return m.Value
	}
	return 0
}

func (m *WeightUnit) GetAccum() float64 {
	if m != nil {
		return m.Accum
	}
	return 0
}

func (m *WeightUnit) GetConsecutive() int32 {
	if m != nil {
		return m.Consecutive
	}
	return 0
}

func (m *WeightUnit) GetCounter() int32 {
	if m != nil {
		return m.Counter
	}
	return 0
}

func (m *WeightUnit) GetPresent() float64 {
	if m != nil {
		return m.Present
	}
	return 0
}

func (m *WeightUnit) GetSubNew() bool {
	if m != nil {
		return m.SubNew
	}
	return false
}

func init() {
	proto.RegisterEnum("digger.EastMoneyType", EastMoneyType_name, EastMoneyType_value)
	proto.RegisterEnum("digger.RMType", RMType_name, RMType_value)
	proto.RegisterEnum("digger.RMState", RMState_name, RMState_value)
	proto.RegisterType((*WeightUnit)(nil), "digger.WeightUnit")
}

func init() { proto.RegisterFile("digger/prober.proto", fileDescriptor_f34ec7a831e4a2b5) }

var fileDescriptor_f34ec7a831e4a2b5 = []byte{
	// 364 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x04, 0x03, 0x02, 0x01, 0x02, 0xff, 0x64, 0x92, 0x4f, 0x6b, 0xe2, 0x40,
	0x18, 0xc6, 0x77, 0xa2, 0x89, 0xbb, 0xaf, 0xa8, 0xe3, 0xe8, 0xae, 0x81, 0xbd, 0x84, 0x3d, 0x89,
	0x07, 0x3d, 0xec, 0x71, 0xf7, 0xb2, 0x0b, 0xa5, 0x2d, 0xf8, 0x8f, 0x58, 0x29, 0xf4, 0x36, 0x49,
	0x5e, 0x62, 0xa8, 0xce, 0x84, 0x99, 0x89, 0xe2, 0xbd, 0xf7, 0x7e, 0x8b, 0x7e, 0xce, 0x92, 0x3f,
	0x52, 0x43, 0x6f, 0xf9, 0xfd, 0x9e, 0xf0, 0xf0, 0x0c, 0xbc, 0x30, 0x88, 0x92, 0x38, 0x46, 0x35,
	0x4b, 0x95, 0x0c, 0x50, 0x4d, 0x53, 0x25, 0x8d, 0x64, 0x4e, 0x29, 0x7f, 0xbd, 0x11, 0x80, 0x47,
	0x4c, 0xe2, 0x9d, 0xd9, 0x8a, 0xc4, 0xb0, 0x21, 0xd8, 0x47, 0xbe, 0xcf, 0xd0, 0x25, 0x1e, 0x19,
	0x13, 0xbf, 0x84, 0xdc, 0xf2, 0x30, 0xcc, 0x0e, 0xae, 0x55, 0xda, 0x02, 0x98, 0x07, 0xed, 0x50,
	0x0a, 0x8d, 0x61, 0x66, 0x92, 0x23, 0xba, 0x0d, 0x8f, 0x8c, 0x6d, 0xff, 0x5a, 0x31, 0x17, 0x5a,
	0xa1, 0xcc, 0x84, 0x41, 0xe5, 0x36, 0x8b, 0xf4, 0x82, 0x79, 0x92, 0x2a, 0xd4, 0x28, 0x8c, 0x6b,
	0x17, 0x9d, 0x17, 0x64, 0x3f, 0xc0, 0xd1, 0x59, 0xb0, 0xc4, 0x93, 0xeb, 0x78, 0x64, 0xfc, 0xd5,
	0xaf, 0x68, 0xf2, 0x4a, 0xa0, 0x73, 0xc3, 0xb5, 0x59, 0x48, 0x81, 0xe7, 0x87, 0x73, 0x9a, 0xb7,
	0x0f, 0x6b, 0x62, 0x2b, 0x9e, 0x85, 0x3c, 0x09, 0xfa, 0x85, 0x8d, 0x60, 0x50, 0x4b, 0xee, 0xe4,
	0x3e, 0x42, 0x45, 0x09, 0xfb, 0x0e, 0xfd, 0x5a, 0xb0, 0xc4, 0x93, 0xa6, 0x16, 0xfb, 0x09, 0xa3,
	0x9a, 0x5e, 0xa5, 0xa8, 0xb8, 0x49, 0xa4, 0xd0, 0xb4, 0xf1, 0xa9, 0xec, 0x76, 0x3d, 0x4f, 0xb4,
	0xa1, 0xcd, 0xc9, 0x5f, 0x70, 0xfc, 0x45, 0xb1, 0xa4, 0x0f, 0x1d, 0xff, 0x50, 0x9f, 0xd0, 0x83,
	0x76, 0xa9, 0x36, 0x3b, 0xa9, 0x0c, 0x25, 0xac, 0x0b, 0x50, 0x8a, 0xb9, 0x14, 0x31, 0xb5, 0x26,
	0x2f, 0x04, 0x5a, 0xfe, 0x62, 0x63, 0xb8, 0x41, 0xc6, 0xa0, 0x5b, 0x7d, 0x7e, 0x14, 0x0c, 0xa0,
	0x57, 0xb9, 0xb5, 0xc2, 0x94, 0x2b, 0x8c, 0x28, 0xb9, 0xfa, 0x71, 0x63, 0xb8, 0x32, 0x18, 0x51,
	0x2b, 0x7f, 0x53, 0xe5, 0xee, 0xc5, 0x5a, 0xc9, 0x58, 0xa1, 0xce, 0x67, 0xe7, 0x03, 0x4a, 0xbd,
	0x3a, 0xa2, 0xa2, 0x4d, 0x36, 0x04, 0x5a, 0x89, 0x7f, 0x01, 0x17, 0x91, 0x14, 0x18, 0x51, 0xfb,
	0x7f, 0xfb, 0xe9, 0xdb, 0x74, 0xf6, 0xa7, 0x3c, 0x86, 0xc0, 0x29, 0x6e, 0xe3, 0xf7, 0x7b, 0x00,
	0x00, 0x00, 0xff, 0xff, 0xf6, 0x8e, 0x01, 0x68, 0x32, 0x02, 0x00, 0x00,
}
